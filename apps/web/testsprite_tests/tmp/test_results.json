[
  {
    "projectId": "ad26eacd-487e-48e9-874e-686e3d64dc38",
    "testId": "5a6cb575-9335-4e8c-9c09-a0879c04a580",
    "userId": "f428f438-e0d1-7076-0ba4-74b878d0676e",
    "title": "TC001-Dashboard Header Displays Real-Time Metrics Correctly",
    "description": "Verify that the dashboard header correctly shows real-time summary metrics excluding canceled guests and updates metrics immediately after data changes.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the Invitados view to manage guests by clicking the 'Invitados' button so guests can be added/updated.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[1]/nav/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Add Guest modal by clicking the 'AÑADIR' button so a new guest can be created.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[1]/div/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the Add Guest form with a new guest ('Test Guest') and save it so the guest can be added to the list (then later cancel a guest and verify header updates). Immediate next action: enter guest details and click 'Guardar Cambios'.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Guest')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Amigo')\n        \n        # -> Click 'Guardar Cambios' (button index 493) to submit the new guest and wait for the page to update so the dashboard and guest list can be re-checked for real-time metric updates.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/form/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the status dropdown for the Test Guest row and choose CANCELADO so the guest is marked canceled, then observe whether the dashboard header updates immediately to exclude the canceled guest.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[2]/div/table/tbody/tr[2]/td[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'CANCELADO' option for Test Guest (index 694) to mark the guest canceled, then extract the dashboard header metrics and the full Invitados list to verify the header updates immediately to exclude canceled guests.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Guests (excluding canceled): 1').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The dashboard header did not update to show the real-time guest count excluding canceled guests after adding a new guest and canceling one. Expected the header to display 'Guests (excluding canceled): 1' but it was not visible, indicating metrics did not update correctly.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Summary of verification attempt and current findings:\n\n1) Current visible header metrics (as of last extraction):\n   - Total Lista: 2\n   - Adultos: 2\n   - Niños: 0\n   - Confirmados: 0\n   - Presupuesto: S/ 300.00\n\n2) Current visible Invitados list (rows shown):\n   - Invitado de Prueba — Adults: 1 — Children: - — Status: PENDIENTE\n   - Test Guest — Adults: 1 — Children: - — Status: PENDIENTE\n   - No guests are currently marked CANCELADO.\n\n3) Observations relevant to verification:\n   - The session included adding a guest and attempting to mark a guest CANCELADO, but the add/save action was ambiguous (modal still displayed filled inputs after clicking 'Guardar Cambios') and the later attempt to set status to CANCELADO did not persist (status remains PENDIENTE). Header metrics also changed unexpectedly during the process (previously different totals), indicating inconsistent real-time behavior.\n   - Because the cancel action did not reliably result in a CANCELADO state, the dashboard header could not be conclusively verified to correctly exclude canceled guests in real time.\n\n4) Conclusion: Verification incomplete/failure. The system did not demonstrate a reliable real-time exclusion of canceled guests because the cancel operation did not persist and header changes were inconsistent. No confirmation that budget/task metrics update in real time (those steps were not reached).\n\n5) Recommended next steps (if continued testing is desired):\n   - Retry saving the new guest and confirm it appears as a row (or reload and re-extract). Ensure the save button is clicked a second time only if necessary (avoid exceeding 2 clicks per element). \n   - Mark one guest CANCELADO and confirm the row status changes to CANCELADO in the list.\n   - Immediately re-check header metrics to confirm Total Lista and Adultos/Confirmados counts exclude the canceled guest.\n   - If header still behaves inconsistently, inspect network requests or backend logs for the change event handling.\n\nResult: Task not completed successfully (success=false).",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f428f438-e0d1-7076-0ba4-74b878d0676e/1769633857530515//tmp/test_task/result.webm",
    "created": "2026-01-28T20:51:50.306Z",
    "modified": "2026-01-28T20:57:37.731Z"
  },
  {
    "projectId": "ad26eacd-487e-48e9-874e-686e3d64dc38",
    "testId": "412e93b7-9c05-45de-a119-615340e970ae",
    "userId": "f428f438-e0d1-7076-0ba4-74b878d0676e",
    "title": "TC002-Guest Management: Add a New Guest Successfully",
    "description": "Validate that users can add a new guest with all required fields and that the new guest appears in the guest list and dashboard metrics.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Añadir' button to open the add-new-guest form.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[1]/div/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the add-guest form (Nombre, Vínculo), select a responsable, and submit the form by clicking 'Guardar Cambios'.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Invitado de Prueba')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Amigo')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[6]/div/button[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Guardar Cambios' (submit) button to submit the new guest form.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/form/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Invitado de Prueba').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test attempted to add a new guest named 'Invitado de Prueba' and verify it appears in the guest list and that dashboard guest metrics incremented, but the guest was not found or the metrics did not update\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test summary and results:\n\nObjective: Validate that users can add a new guest with all required fields and that the new guest appears in the guest list and dashboard metrics.\n\nActions performed:\n- Opened Guests tab.\n- Opened the Add Guest modal and filled required fields:\n  - Nombre: Invitado de Prueba\n  - Vínculo: Amigo\n  - Grupo: Familia Directa (default)\n  - Adultos: 1\n  - Niños: 0 (displayed as '-')\n  - Responsables: Zara\n- Submitted the form (Guardar Cambios).\n- Verified the new guest appears in the guest list and extracted dashboard metrics.\n\nExtracted page values (exact text shown):\n- Dashboard metrics:\n  - Total Lista: 2\n  - Adultos: 2\n  - Niños: 0\n  - Confirmados: 1\n  - Pendientes: 1 (displayed as \"1 Pendientes\")\n  - Presupuesto: S/ 300.00\n\n- Guest row for 'Invitado de Prueba':\n  - Nombre: Invitado de Prueba\n  - Vínculo: Amigo\n  - Grupo: Familia Directa\n  - Responsables: Zara\n  - Adultos: 1\n  - Niños: -\n  - Estado: PENDIENTE\n\nValidation result:\n- Guest creation and presence in the guest list: SUCCESS — the guest appears with all provided details.\n- Dashboard metric increment: NOT VERIFIED — current dashboard numbers were extracted, but baseline values prior to adding the guest were not recorded in this session, so it is not possible to definitively prove that the metrics incremented as a direct result of this add. The dashboard currently shows Total Lista: 2 and Adultos: 2 which is consistent with one additional adult being present, but this cannot be asserted as an increment without prior values.\n\nRecommendation to fully validate metric increment:\n- Capture dashboard metrics before performing the add action (record Total Lista, Adultos, Niños, Confirmados, Pendientes, Presupuesto), then add the guest and re-extract metrics to compare.\n- Alternatively, re-run the test starting from a known baseline (e.g., an isolated test environment with a single known guest) and compare values before/after.\n\nConclusion: The add-guest user flow works and the new guest appears with correct details (SUCCESS). Verification of metric increments requires baseline numbers and therefore could not be completed here (FAIL for that sub-assertion).",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f428f438-e0d1-7076-0ba4-74b878d0676e/1769633731890691//tmp/test_task/result.webm",
    "created": "2026-01-28T20:51:50.312Z",
    "modified": "2026-01-28T20:55:32.003Z"
  },
  {
    "projectId": "ad26eacd-487e-48e9-874e-686e3d64dc38",
    "testId": "6d6cc007-1f18-435b-ad41-26f77ddc57e0",
    "userId": "f428f438-e0d1-7076-0ba4-74b878d0676e",
    "title": "TC003-Guest Management: Form Validation for Adding/Editing Guests",
    "description": "Ensure form validation works properly enforcing required fields and minimum character limits with live feedback on validation errors on the guest form.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the 'Añadir' guest form by clicking the 'AÑADIR' button so validation testing can begin.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[1]/div/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Enter invalid/too-short values into 'Nombre' and 'Vínculo', trigger blur to show live validation messages, capture the error texts, then correct the fields, select a responsable, and submit the form.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('A')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('x')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[3]/select').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Trigger blur so live validation messages appear and extract the error texts for 'Nombre' and 'Vínculo'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/form/div[1]/div[6]/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Trigger a different blur target (click the 'Adultos' input) to cause live validation to run, wait, then extract visible validation error messages for 'Nombre Completo' and 'Vínculo'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/form/div[1]/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the form submit button 'Guardar Cambios' to force validation messages to appear and then extract any visible validation error texts for 'Nombre Completo' and 'Vínculo'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/form/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill 'Nombre Completo' with a valid full name and 'Vínculo' with a valid relation, then submit the form to verify errors clear and the form accepts the submission.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[3]/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Ana Perez')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[3]/form/div[1]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Amigo')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/form/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Invitado guardado correctamente').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test attempted to verify that after correcting validation errors on the guest form the submission succeeded and a confirmation message 'Invitado guardado correctamente' appeared, but the success message did not show and the form may not have been submitted.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Summary of results:\n- What was tested: Add/Edit guest modal validation for 'Nombre Completo' and 'Vínculo' (required and min-length behavior + live feedback expectation).\n- Observations:\n  - Live validation on blur was NOT observed. Two different blur targets were tried; no inline/live error messages appeared.\n  - Submit-time validation prevented form submission when 'Nombre' was invalid/missing and displayed the error text: 'El nombre es obligatorio'.\n  - 'Vínculo' did not show a visible validation message during these attempts (neither on blur nor after submit).\n  - After correcting fields to valid values (Nombre='Ana Perez', Vínculo='Amigo') and selecting responsables, clicking 'Guardar Cambios' closed the dialog and the form was accepted (submission succeeded).\n- Conclusion: Server/client-side enforcement for required fields works at submit; live (on-blur) validation feedback was not observed, so the live-feedback requirement is not satisfied.\n- Recommendation: If live validation on blur is required, implement or enable client-side validation that shows inline messages on blur/input; re-run the blur-check step after implementation.\n- Test coverage: 5 planned steps — completed 4/5. The remaining step (verify live validation appears on blur) failed and requires code changes or further investigation to pass.\n\nResult: Task partially completed. Live feedback requirement not met.\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f428f438-e0d1-7076-0ba4-74b878d0676e/1769633813669054//tmp/test_task/result.webm",
    "created": "2026-01-28T20:51:50.354Z",
    "modified": "2026-01-28T20:56:53.819Z"
  },
  {
    "projectId": "ad26eacd-487e-48e9-874e-686e3d64dc38",
    "testId": "69512c22-dbf3-4053-aa5a-9bdbcb13cd4b",
    "userId": "f428f438-e0d1-7076-0ba4-74b878d0676e",
    "title": "TC004-Guest Management: Change Guest Attendance Status",
    "description": "Check that changing a guest's attendance status via the dropdown using React Portals updates UI and persists the change in the backend.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the attendance dropdown for the first guest (CARLOS) to change their status.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[2]/div/table/tbody/tr[1]/td[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the PENDIENTE option (index 440) in the attendance dropdown to change CARLOS' status to Pending.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Read the CARLOS row status text from the UI to verify the immediate update, then reload the page to verify the change persists.\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Wait for the guest list to load (or force reload via the Invitados tab), reveal the guest rows, then read CARLOS row status text to verify the immediate UI update.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[1]/nav/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Read the guest row status text from the UI for the first visible guest (INVITADO DE PRUEBA) to verify the immediate update, then reload the page to verify persistence.\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the 'TEST GUEST' attendance dropdown, change status to a different value, confirm the UI updates immediately by extracting guest rows, then reload the Invitados view and extract guest rows again to confirm persistence.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[2]/div/table/tbody/tr/td[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[2]/div/table/tbody/tr/td[6]/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the 'Editar Invitado' modal, scroll to reveal the guest list, then extract visible guest rows to find 'CARLOS' (preferred) or 'Test Guest' and return their attendance_text and any nearby interactive element index hints.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/form/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open Ana Perez's attendance dropdown and change status to CONFIRMADO, extract visible guest rows to verify the UI updated immediately, then reload the Invitados view and extract again to confirm persistence.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[2]/div/table/tbody/tr/td[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[2]/div/table/tbody/tr/td[6]/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the Edit Guest modal, reveal the guest list, then extract visible guest rows to find 'CARLOS' (preferred) or fallback to a visible guest (Ana or Test Guest) and return their attendance_text and any nearby interactive element index hints.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/form/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the 'Añadir' (Add Guest) control to create a test guest so the attendance dropdown behavior can be exercised and persisted.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[1]/div/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the 'Añadir Invitado' form to create a test guest and save it so attendance behavior can be tested and persisted.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Automation Test')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Primo')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[6]/div/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Guardar Cambios' to save the new 'Automation Test' guest so attendance behavior can be tested and persisted.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/form/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Refresh the Guests view and check the rendered guest rows to find 'Automation Test'. If no rows are found, report the empty state. Immediate action: click the 'Invitados' tab, wait, scroll to reveal list, then extract visible guest rows (name, attendance_text, row_index_hint).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[1]/nav/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open 'Automation Test' attendance dropdown (click index 1741), select CONFIRMADO (click index 1751), verify immediate UI by extracting guest rows, then refresh the Invitados view (click index 1032), wait/scroll to reveal list and extract guest rows again to confirm persistence.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[2]/div/table/tbody/tr/td[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[2]/div/table/tbody/tr/td[6]/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f428f438-e0d1-7076-0ba4-74b878d0676e/1769634306128281//tmp/test_task/result.webm",
    "created": "2026-01-28T20:51:50.360Z",
    "modified": "2026-01-28T21:05:06.277Z"
  },
  {
    "projectId": "ad26eacd-487e-48e9-874e-686e3d64dc38",
    "testId": "0d6b2c5c-9054-43d2-a943-37d028414fa0",
    "userId": "f428f438-e0d1-7076-0ba4-74b878d0676e",
    "title": "TC005-Guest Management: Delete a Guest",
    "description": "Validate the functionality to delete a guest from the guest list updates UI and backend, and dashboard metrics update accordingly.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Ensure the Guests (Invitados) tab is active and wait for the guest list to finish loading so delete controls and guest rows become visible.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[1]/nav/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the delete (trash) button for the first guest (CARLOS) to initiate deletion confirmation.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[2]/div/table/tbody/tr[3]/td[6]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the delete (trash) button for the first guest (CARLOS) to open the deletion confirmation dialog, then confirm deletion and verify the guest row is removed.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[2]/div/table/tbody/tr[1]/td[6]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the trash (delete) button for the guest row to open the deletion confirmation dialog (attempt 2 of 2).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[2]/div/table/tbody/tr/td[6]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the guest management/edit options for the guest row (PEPE) to look for an alternative delete control or a details view that allows deletion (click the edit/pencil button).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[2]/div/table/tbody/tr/td[6]/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the trash/delete icon for the guest (index 451) to open the deletion confirmation dialog.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[2]/div/table/tbody/tr/td[6]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the guest details/edit view (click edit/pencil index 450) to look for an alternative delete control or confirm option, then wait for the UI to update or show a confirmation modal.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[2]/div/table/tbody/tr/td[6]/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the trash/delete icon for the visible guest row to open the deletion confirmation dialog (use delete button index 508).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[2]/div/table/tbody/tr/td[6]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the guest details/edit view using the edit (pencil) button at index 507 to locate a delete/confirm option or alternative removal control.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[2]/div/table/tbody/tr/td[6]/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Añadir' button to add a test guest so the deletion flow (confirmation modal, UI removal, dashboard update, persistence) can be exercised.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[1]/div/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the 'Añadir Invitado' form with a test guest (name: 'Test Delete') and submit to create the guest so the deletion flow can be exercised.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Delete')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Primo')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[6]/div/button[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Submit the 'Añadir Invitado' form to create the test guest so the deletion flow can be exercised (click 'Guardar Cambios' button).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/form/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Ensure the test guest is actually created: re-open the 'Añadir' modal if needed, set the test guest fields (Nombre='Test Delete', Vínculo='Primo') and submit the form to add the guest, then wait for the guest to appear in the list.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[3]/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Delete')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[3]/form/div[1]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Primo')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/form/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the trash/delete button for the 'Test Delete' guest (button index 736) to open the deletion confirmation dialog.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[2]/div/table/tbody/tr[2]/td[6]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the trash/delete button for the 'Test Delete' guest (use delete button index 708) to open the deletion confirmation dialog.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[2]/div/table/tbody/tr/td[6]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the guest edit/details view by clicking the edit/pencil button (index 707) to find an alternative delete/confirmation control or to confirm deletion there.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[2]/div/table/tbody/tr/td[6]/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the 'Añadir' modal to add a new test guest so the delete flow can be exercised (click 'Añadir').\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[1]/div/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the 'Añadir Invitado' form with a new test guest (Nombre: 'Test Delete 2', Vínculo: 'Primo'), select responsible 'Zara', and submit the form to create the guest.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Delete 2')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Primo')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/div[6]/div/button[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Submit the 'Añadir Invitado' form (click 'Guardar Cambios' button index 830) to create 'Test Delete 2', then proceed to delete and validate persistence.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/form/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the trash/delete button for 'Test Delete 2' (button index 939) to open the deletion confirmation dialog.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[2]/div/table/tbody/tr/td[6]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the guest edit/details (click index 938) to find or re-trigger the delete/confirmation flow, attempt the delete action again (index 939) and then read the page text to determine whether the guest row is removed and whether the top 'personas en lista' metric changed.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[2]/div/table/tbody/tr/td[6]/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[2]/div/table/tbody/tr/td[6]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Refresh the Guests view by switching to the Presupuesto tab (index 155) then back to Invitados (index 146) to force a view reload, then extract the visible dashboard metrics and guests table text to determine current persisted state.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[1]/nav/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[1]/nav/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f428f438-e0d1-7076-0ba4-74b878d0676e/176963433745676//tmp/test_task/result.webm",
    "created": "2026-01-28T20:51:50.366Z",
    "modified": "2026-01-28T21:05:37.625Z"
  },
  {
    "projectId": "ad26eacd-487e-48e9-874e-686e3d64dc38",
    "testId": "75568a96-9642-4724-9126-9284699c40e6",
    "userId": "f428f438-e0d1-7076-0ba4-74b878d0676e",
    "title": "TC006-Budget Management: Add New Expense with Proper Validation",
    "description": "Ensure expenses can be added using the expense form with correct fields following schema validations and feedback on errors.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Presupuesto' (Budget) tab to open the Budget view (click element index 150).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[1]/nav/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Añadir' button in the Presupuesto view to open the add-expense form (element index 325).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[2]/div/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Guardar Cambios' (element index 461) to submit the form with current invalid/missing values and observe live validation errors.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[4]/form/div[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill required fields with valid data (Concepto and Monto Estimado), select a responsable, then submit the form to add the expense.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Torta')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[3]/form/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('120.50')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/form/div[3]/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Guardar Cambios' button to submit the valid expense and then verify the new expense appears in the expense list.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/form/div[5]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f428f438-e0d1-7076-0ba4-74b878d0676e/1769633819639658//tmp/test_task/result.webm",
    "created": "2026-01-28T20:51:50.371Z",
    "modified": "2026-01-28T20:56:59.773Z"
  },
  {
    "projectId": "ad26eacd-487e-48e9-874e-686e3d64dc38",
    "testId": "661d8cb1-8ab9-4777-ad74-3099c050660d",
    "userId": "f428f438-e0d1-7076-0ba4-74b878d0676e",
    "title": "TC007-Budget Management: Track Partial and Full Payments",
    "description": "Verify that payments made by multiple responsible parties can be recorded per expense and that the payment progress visualization updates correctly in real-time.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Presupuesto' (Budget) tab to open the Budget view (use element index 150).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[1]/nav/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Select the existing expense to open its management/detail view by clicking the expense management button (index 528).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[3]/div/table/tbody/tr/td[5]/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Record a partial payment by Jose (update Jose's input at index 674 from 100 to 125) so paid goes from S/250.00 to S/275.00, then verify the summary updates. After that, record remaining payment(s) (e.g., update Luis at index 683 from 50 to 75), save changes (index 626) and verify final paid S/300.00 / S/300.00.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[4]/div[3]/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('125')\n        \n        # -> Update Luis's payment input to S/75.00 (index 683) then save changes (click Guardar Cambios index 626) to apply payments and verify final payment state.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[3]/form/div[4]/div[3]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('75')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/form/div[5]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f428f438-e0d1-7076-0ba4-74b878d0676e/1769633708683658//tmp/test_task/result.webm",
    "created": "2026-01-28T20:51:50.378Z",
    "modified": "2026-01-28T20:55:08.833Z"
  },
  {
    "projectId": "ad26eacd-487e-48e9-874e-686e3d64dc38",
    "testId": "f5b726a8-05ea-450e-ac73-2e881d811794",
    "userId": "f428f438-e0d1-7076-0ba4-74b878d0676e",
    "title": "TC008-Budget Management: Edit and Delete Expenses",
    "description": "Test that expenses can be edited and deleted with immediate UI updates and backend persistence.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Presupuesto' (Budget) tab to open the Budget view.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[1]/nav/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the edit form for the existing expense by clicking the edit (pencil) button (index 485).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[3]/div/table/tbody/tr/td[5]/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Edit the expense: change Concepto to 'torta grande', change Monto Estimado to 250, then click 'Guardar Cambios' to save the edit.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('torta grande')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[4]/form/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('250')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[4]/form/div[5]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the edit modal so the expense list is visible and then verify whether the list reflects the updated concept and amount.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/form/div[5]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the delete (trash) button for the edited expense to remove it from the list (use element index 486).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[3]/div/table/tbody/tr/td[5]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the delete (trash) button for the expense using interactive element index 808 and observe whether a confirmation modal appears or the row is removed. If a confirmation appears, plan to click its confirm button next.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[3]/div/table/tbody/tr/td[5]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=torta grande').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test attempted to verify that editing an expense updated the list to show 'torta grande' (amount 250) and that deletion would remove it; expected the updated expense 'torta grande' to be visible in the expense list immediately after saving, but it was not found — indicating the UI did not reflect the edit or the save/delete operation failed.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test summary and results:\n\nGoal: Verify expenses can be edited and deleted with immediate UI updates and backend persistence.\n\nWhat was performed (step-by-step):\n- Navigated to the app and opened the 'Presupuesto' (Budget) tab.\n- Located an existing expense and opened the edit modal.\n- Edited the expense: Concepto changed to 'torta grande' and Monto Estimado changed to 250. Clicked 'Guardar Cambios'.\n- Closed the modal and verified the expense list showed the updated values (Concepto: 'torta grande', Costo: S/ 250.00) — UI edit succeeded.\n- Attempted to delete the expense by clicking the trash button (two attempts: element indexes 486 and 808). The UI later displayed 'No hay gastos registrados todavía.' indicating the list is empty — UI deletion appears to have succeeded.\n\nBackend verification attempts and results:\n- Probed likely API endpoints from the page context: /api/gastos, /api/expenses, /gastos, /expenses.\n- All four probes returned 404 Not Found. No backend data confirming the expense exists or was removed was obtained.\n- A prior JavaScript DOM inspection attempt produced an execution error once; a later evaluate returned page snippets consistent with no expenses.\n\nConclusion:\n- UI behavior: Success — edits are reflected immediately in the UI; deletion resulted in the UI showing no expenses.\n- Backend persistence: Failure / Unknown — unable to confirm via API probes (404 responses). Backend deletion persistence cannot be verified from the available endpoints.\n\nRecommendations to fully verify backend persistence (next actions the team can take):\n1) Confirm the correct API base path and endpoints for expenses in the running backend (the app may use a different route or proxy). Check server logs or the app's network requests in DevTools while performing edit/delete to see the exact request URLs and responses.\n2) If the backend is expected to expose /api/gastos or similar, ensure the backend server is running and properly mounted during the test.\n3) Re-run probes against the exact endpoints observed in network traffic (including query params or auth headers if required). If authentication or CSRF tokens are required, include them.\n4) If direct API checking is not possible, inspect persistence layer (database) or backend logs to confirm deletion.\n\nIf further automated checks are desired, provide: the correct API base path (or allow capturing network requests) and any required auth headers so the test can re-check backend persistence. Current automated test result: success=false because backend persistence was not verified.\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f428f438-e0d1-7076-0ba4-74b878d0676e/1769633888694684//tmp/test_task/result.webm",
    "created": "2026-01-28T20:51:50.384Z",
    "modified": "2026-01-28T20:58:08.837Z"
  },
  {
    "projectId": "ad26eacd-487e-48e9-874e-686e3d64dc38",
    "testId": "152e16eb-bca8-4d64-89b9-1b8feed8e552",
    "userId": "f428f438-e0d1-7076-0ba4-74b878d0676e",
    "title": "TC009-Task Management: Mark Tasks as Completed and Uncompleted",
    "description": "Confirm tasks can be toggled between completed and uncompleted states with instant database synchronization and UI update.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Logística' tab button to open the Logistics view so tasks can be located and toggled.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[1]/nav/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the 'Nueva Tarea' dialog to create a logistics task so it can be toggled.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[1]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the currently open FORMULARIO modal and re-open the 'Nueva Tarea' dialog, then run a robust in-page JS enumeration (including shadowRoots) to locate input/select/textarea/button elements so a task can be created.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the open FORMULARIO modal (click the close button) and then scroll the Logistics view to look for alternate ways to create or list tasks (so a task can be created for toggling).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the 'Nueva Tarea' dialog (click the 'NUEVA TAREA' button) and run a robust in-page JS traversal (including shadowRoots) to enumerate any input/select/textarea/button/contenteditable/role='textbox' controls so the task creation fields and submit button can be identified.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[1]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the open FORMULARIO modal (use the dialog's close button) to return to the Logistics view so alternate creation methods or further inspection can proceed.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the 'Nueva Tarea' dialog so the task creation form can be inspected and a task created (then proceed to toggle it).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the 'Nueva Tarea' dialog so the task creation form becomes available for inspection and creation of a test task.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[1]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Summary of results and blocking issues:\n- Completed steps: Navigated to app (http://localhost:3000) and opened the 'Logística' tab.\n- The 'Nueva Tarea' (FORMULARIO) modal was opened multiple times and is visible, but form input controls could not be located. DOM queries (including shadowRoot-traversal scripts) repeatedly returned only the dialog container and one or two button elements (likely close buttons). JavaScript traversal attempts sometimes threw errors. As a result, no task could be created, so toggling a task to completed/uncompleted and verifying database synchronization could not be performed.\n- Blocking cause observed: Task creation form controls appear to be encapsulated in a way that prevented automated DOM access (likely custom elements/shadow DOM/portal rendering). Without access to the form controls or an alternative creation method (API or test fixture), it is not possible to perform the required toggle and persistence checks.\nRecommended next actions to proceed:\n1) Provide a direct selector or steps to access the form controls inside the modal (e.g., names/ids of inputs or how to access they are exposed), or update the UI to expose inputs in the light DOM for testing.\n2) Alternatively, provide an API endpoint or test data seed that creates a logistics task so the toggle and persistence checks can be executed.\n3) If allowed, grant credentials or developer guidance to run scripts inside the app context to create a task.\nCurrent status: Unable to confirm toggling behavior due to inability to create or locate a task. Test incomplete (success=false).",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f428f438-e0d1-7076-0ba4-74b878d0676e/1769634128339475//tmp/test_task/result.webm",
    "created": "2026-01-28T20:51:50.389Z",
    "modified": "2026-01-28T21:02:08.518Z"
  },
  {
    "projectId": "ad26eacd-487e-48e9-874e-686e3d64dc38",
    "testId": "0b2bcb47-1215-427a-9d6b-944e08a93f5d",
    "userId": "f428f438-e0d1-7076-0ba4-74b878d0676e",
    "title": "TC010-Task Management: Delete Completed Task",
    "description": "Validate that deleting a completed task removes it from UI and backend immediately with appropriate user feedback.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Logística' tab to open the logistics view.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[1]/nav/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Nueva Tarea' button to create a new logistics task so it can be completed and then deleted for validation.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[1]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Task deleted successfully').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test attempted to verify that deleting a completed task removes it from the UI and backend and displays a confirmation message ('Task deleted successfully'), but the confirmation message did not appear.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Unable to validate deletion of a completed task because of two blocking issues:\n\n1) No tasks present: The Logistics page shows 'No hay herramientas de logística configuradas.' There are 0 lists / 0 pending items, so there is no completed task available to delete.\n\n2) Task creation form is broken/unusable: Clicking 'Nueva Tarea' opened a modal titled 'FORMULARIO' (dialog element index [324]), but the modal contains only a close button (button index [321]) and no input fields, textareas, selects, contenteditable elements, role=textbox, or submit button were detected. The screenshot confirms the modal shows only the title and an X button.\n\nBecause of these, the requested validation (delete a completed task and confirm immediate removal from UI and backend with feedback) cannot be performed.\n\nReproduction steps:\n- Navigate to http://localhost:3000\n- Click 'Logística' tab\n- Observe message: 'No hay herramientas de logística configuradas.'\n- Click 'Nueva Tarea' -> modal opens (FORMULARIO) but no inputs/submit present (dialog [324], button [321]).\n\nSuggested next actions to enable validation (choose one):\n- Fix the FORMULARIO modal so input fields and a submit/save control are rendered and accessible; then retry: create task -> mark completed -> delete -> verify UI and backend and refresh.\n- Or provide an API/test endpoint or test data insertion so a completed task exists; then retry deletion and verification.\n- As a debugging aid, inspect the network endpoints (POST /tasks, DELETE /tasks/:id) and confirm whether the backend is reachable; provide the API details if available so the agent can create/delete tasks via the API.\n\nIf any of the above fixes or test data are provided, instruct the agent to continue and validation will be attempted. Current status: validation not performed. Blocking issues reported.\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f428f438-e0d1-7076-0ba4-74b878d0676e/1769633695205409//tmp/test_task/result.webm",
    "created": "2026-01-28T20:51:50.395Z",
    "modified": "2026-01-28T20:54:55.333Z"
  },
  {
    "projectId": "ad26eacd-487e-48e9-874e-686e3d64dc38",
    "testId": "1722345c-a8f9-4f24-8c65-7289ca176314",
    "userId": "f428f438-e0d1-7076-0ba4-74b878d0676e",
    "title": "TC011-Export Function: Export Guest Data to Excel and PDF",
    "description": "Test that guest data can be exported accurately into Excel and PDF formats reflecting current filtered data and structure.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Extract the visible guest list data from the page, then trigger Excel export and check for any downloadable link; finally trigger PDF export and check for any downloadable link.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[1]/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the Excel (.xlsx) export button to trigger the download/export and wait for the response (look for download link or new tab).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[1]/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the PDF export button to trigger PDF generation and wait for a response/download link.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[1]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test summary and results:\n\n1) What was tested:\n- Verified the Guests tab is open and visible guest list is loaded.\n- Extracted the visible guest rows from the table.\n- Triggered Excel export (Excel (.xlsx) button clicked twice).\n- Triggered PDF export (PDF button clicked once).\n\n2) Extracted visible guest data (current page view) — returned as JSON:\n[\n  {\n    \"name\": \"carlos\",\n    \"subgroup\": \"cfedcedc • Familia Directa\",\n    \"adults\": \"1\",\n    \"children\": \"-\",\n    \"responsables\": [\"LuisZaraCarlos\"],\n    \"estado\": \"CONFIRMADO\"\n  },\n  {\n    \"name\": \"pepe\",\n    \"subgroup\": \"• Familia Directa\",\n    \"adults\": \"1\",\n    \"children\": \"-\",\n    \"responsables\": [\"Luis\"],\n    \"estado\": \"CONFIRMADO\"\n  },\n  {\n    \"name\": \"roger\",\n    \"subgroup\": \"• Familia Directa\",\n    \"adults\": \"1\",\n    \"children\": \"-\",\n    \"responsables\": [\"CarlosZaraLuis\"],\n    \"estado\": \"CONFIRMADO\"\n  }\n]\n\n3) Export attempts and observations:\n- Excel export: Button clicked twice. No downloadable link or file element appeared in the page DOM. Possible explanations: the export was started and the browser download manager handled the .xlsx file outside the page DOM, or the export failed silently on the server. No in-page confirmation or link available to inspect.\n- PDF export: Button clicked once. No downloadable link or file element appeared in the page DOM. Same possible explanations as for Excel.\n- No new tabs were opened and no DOM elements indicating download URLs or generated file previews were found.\n\n4) Verification status:\n- Verification of downloaded Excel contents: NOT COMPLETED. File not accessible from page DOM; cannot confirm contents here.\n- Verification of downloaded PDF contents: NOT COMPLETED. File not accessible from page DOM; cannot confirm contents here.\n\n5) Limitations and next steps suggested:\n- Limitation: This environment cannot access the browser's download manager or local filesystem to read downloaded files. Exports that trigger browser-managed downloads will not be visible in the page DOM for verification.\n\nRecommended actions to complete verification:\n- Provide the downloaded .xlsx and .pdf files (upload them here) so their contents can be inspected and compared to the extracted guest JSON above.\n- Or grant access to the application endpoint that generates the export (URL or API) so the export can be fetched directly from the server and inspected.\n- Alternatively, implement an in-app confirmation (e.g., a download link or preview) that appears in the DOM after export; this would allow verification from this environment.\n\n6) Current result: Test partially completed. Export actions were triggered but file contents could not be verified due to download visibility limitations. Requesting user direction: either upload the exported files, provide an export endpoint URL, or allow reattempt with in-DOM download link.\n\nIf the user prefers, next automated step available: attempt the PDF export one more time (one allowed attempt remaining) or attempt alternate navigation to an export endpoint if provided. Otherwise the test is complete here.\n\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f428f438-e0d1-7076-0ba4-74b878d0676e/1769633739966832//tmp/test_task/result.webm",
    "created": "2026-01-28T20:51:50.400Z",
    "modified": "2026-01-28T20:55:40.108Z"
  },
  {
    "projectId": "ad26eacd-487e-48e9-874e-686e3d64dc38",
    "testId": "da33fe62-b3e8-4b3b-9a4b-e2e1e2580207",
    "userId": "f428f438-e0d1-7076-0ba4-74b878d0676e",
    "title": "TC012-Export Function: Export Expense Data to Excel and PDF",
    "description": "Ensure expense data exports to Excel and PDF formats correctly representing current expense statuses and payments.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Presupuesto' (Budget) tab to open the Budget view (use element index 150).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[1]/nav/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the Excel export button to trigger the Excel download (element index 323).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[2]/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Install JS hooks to capture created blob URLs or anchor downloads, re-trigger the Excel export to capture the file blob/metadata, then trigger the PDF export and capture its blob/metadata for verification.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[2]/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fetch the captured Excel blob from window.__downloads and convert to base64, then trigger the PDF export (click element 324), wait, and fetch the new download blob(s) (PDF) as base64 for verification.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[2]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Install a stronger page-side hook (override URL.createObjectURL) that immediately converts blobs to base64 when created, re-trigger the Excel export (click Excel button index 323) and capture the base64 result; then retrieve captured data for verification.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[2]/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Re-trigger the PDF export (click element index 324), wait for the download entry to appear, then run a robust page-context conversion routine to read window.__downloads entries (XHR->blob fallback and FileReader) and return filename, mime, size, url and base64 (or detailed errors) for each captured download so files can be verified.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[2]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Summary of results and next steps:\n\nWhat was attempted:\n- Opened site and navigated to Budget (Presupuesto) view.\n- Triggered Excel export (clicked Excel button index 323) and PDF export (clicked PDF button index 324) multiple times with download-capture hooks installed.\n- Installed page-side download hooks that populate window.__downloads. window.__downloads shows metadata for the exported files (Excel filename and blob: URLs for Excel and PDF).\n- Multiple strategies were attempted to convert captured blob: URLs to base64 in page context (fetch blob URL, FileReader on blob, override createObjectURL to intercept blobs). All conversion attempts failed with errors such as 'Failed to fetch', 'xhr_error', and 'no_blob_or_url_or_data'. An override attempt caused a JS exception.\n\nWhat was observed:\n- window.__downloads contains entries indicating the exports were created, for example:\n  - Excel: download 'Presupuesto_Fiesta_2026-01-28.xlsx' referenced by blob:http://localhost:3000/a9d2a0eb-... (metadata keys present but no stored Blob object or inline base64 data available).\n  - PDF(s): blob URLs present with metadata (type, size, time, url) but base64 conversion failed.\n- The page UI displays expense totals and the detailed expense row (TORTA) with expected payment breakdowns and status 'EN PROCESO', so the UI data appears correct visually.\n\nWhy verification failed:\n- The captured download records contain only blob: URLs or metadata; the actual Blob objects were not available in window.__downloads entries for conversion.\n- Fetching blob: URLs from the page context repeatedly failed (browser returned 'Failed to fetch' / XHR errors). FileReader conversions also failed because no direct Blob object was present to read.\n- Overriding URL.createObjectURL to intercept blob creation failed with a JS exception in the page environment.\n\nRecommendations to enable verification (pick one or more):\n1) Provide direct downloadable endpoints: Expose a server URL (e.g., /export/presupuesto.xlsx and /export/presupuesto.pdf) that returns the generated files; then the files can be downloaded and verified via HTTP.\n2) Modify download hook to store file data (base64) directly in window.__downloads when creating the blob (e.g., when creating the Blob, also do reader.readAsDataURL(blob) and store the data string in the hook). Example stored entry: {download: 'Presupuesto_....xlsx', data: 'data:application/vnd.openxmlformats-...;base64,...'}.\n3) Keep the Blob object reference in window.__downloads instead of only the URL so FileReader can read it later (e.g., window.__downloads.push({blob: myBlob, download: '...'}) ).\n4) Make the export open in a new tab with a data: URL or expose the raw bytes in a JS variable so the automation can retrieve them.\n\nIf one of the above changes is made, the following verification steps will be executed:\n- Retrieve base64 bytes for each exported file (Excel and PDF).\n- For Excel: parse workbook, verify rows include expense concept 'TORTA', payments (Jose 100, Luis 50, Carlos 100), total 300, paid 250, pending 50, and status 'EN PROCESO'.\n- For PDF: verify the visual/report includes the same expense numbers and progress indicators.\n\nCurrent status: verification incomplete. Success: false.\n\nIf additional instructions are provided (e.g., enable a server endpoint or store base64 in window.__downloads), the automation can retry verification immediately.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f428f438-e0d1-7076-0ba4-74b878d0676e/1769634088833008//tmp/test_task/result.webm",
    "created": "2026-01-28T20:51:50.406Z",
    "modified": "2026-01-28T21:01:28.943Z"
  },
  {
    "projectId": "ad26eacd-487e-48e9-874e-686e3d64dc38",
    "testId": "724f20c4-7f9d-475c-92b0-28d5928163b2",
    "userId": "f428f438-e0d1-7076-0ba4-74b878d0676e",
    "title": "TC013-UI/UX States: Loading and Empty Data Feedback",
    "description": "Verify loading indicators display during data fetching and appropriate empty state messages appear when no guests, expenses, or tasks exist.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Invitados' tab (index 141) to trigger/confirm the loading indicator, then navigate to Presupuesto (index 150) and Logística (index 7) to check their loading indicators and empty-state messages.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[1]/nav/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[1]/nav/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Simulate a slow network by monkey-patching window.fetch (delay responses), then click Invitados (141), wait, click Presupuesto (150), wait, click Logística (7), wait — to observe loading indicators in each tab.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[1]/nav/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click Presupuesto (index 150) to observe loading indicator under the simulated delay, wait to let loading appear, then click Logística (index 7) and wait, then open Configuración (index 173) to look for backend-clear/reset options.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[1]/nav/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[1]/nav/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open Configuración (index 173) to find the backend-clear/reset option so guests/expenses/tasks can be cleared.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[1]/nav/button[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Clear app data (localStorage/sessionStorage/IndexedDB/Cache) in the current tab to simulate an empty backend, then open the app in a new tab so loading indicators and empty-state messages can be re-verified under a simulated slow network.\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Patch window.fetch in the current tab to simulate ~1500ms delay, then click Invitados, wait to observe loading indicator, click Presupuesto, wait, click Logística, wait, and extract page content to verify loading indicators and empty-state messages for each tab.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[1]/nav/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click Presupuesto (index 1219) to observe loading indicator under the simulated delay, wait to let the loading UI appear, then click Logística (index 1073), wait, then extract visible page text to verify presence of loading indicators (e.g., 'Cargando') and empty-state messages (e.g., 'No hay ... registrado').\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[1]/nav/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[1]/nav/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Install a robust DOM observer in the current page, programmatically click Invitados -> Presupuesto -> Logística (one extra click each allowed in this tab) while waiting briefly to let the simulated delay produce loading UI, then extract any captured loading indicators and all 'No hay' empty-state text lines.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[1]/nav/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f428f438-e0d1-7076-0ba4-74b878d0676e/1769634076320838//tmp/test_task/result.webm",
    "created": "2026-01-28T20:51:50.414Z",
    "modified": "2026-01-28T21:01:16.473Z"
  },
  {
    "projectId": "ad26eacd-487e-48e9-874e-686e3d64dc38",
    "testId": "1b8108b2-abe2-420a-bbe9-66ef221a36ed",
    "userId": "f428f438-e0d1-7076-0ba4-74b878d0676e",
    "title": "TC014-UI/UX States: Error Handling During Data Operations",
    "description": "Confirm that the system gracefully handles errors during CRUD operations with clear error messaging and no UI crashes.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Submit the 'Añadir Invitado' form to trigger the mocked server error for guest creation, wait for the UI error message or toast, and extract any visible error text or indicators that the UI remained stable and retry is possible.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[3]/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Prueba Error')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[3]/form/div[1]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Amigo')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[3]/form/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Presupuesto (budget/expenses) section so an expense can be added and the mocked server error for expense creation can be triggered and verified.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[1]/nav/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the 'Añadir' control in the Presupuesto section to open the add-expense modal so an expense creation can be submitted (to trigger the mocked server error) and then scan for error messages.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[1]/div/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Summary of findings and conclusion:\n\n- Setup performed: window.fetch was patched to return simulated server errors for guests, expenses, and tasks.\n\n- Guest-add (create guest): The 'Añadir Invitado' modal was opened and the form was submitted once while fetch returned errors. Outcome: the modal closed and no visible error message, toast, or aria-live alert appeared. DOM scan returned no matches. The application UI did not crash, but there is no visible error feedback or retry affordance for the user. Therefore error-handling for this CRUD operation could not be confirmed as graceful or user-friendly.\n\n- Expense creation: The Presupuesto tab was opened and the 'Añadir' control was clicked to open the add-expense modal, but the expense form was not submitted. Error-handling for expense creation remains untested.\n\n- Task update: Not attempted; error-handling for task updates remains untested.\n\nOverall conclusion: Cannot confirm that the system gracefully handles backend errors for CRUD operations. Evidence shows at least one failure case (guest creation) where no error message was surfaced even though fetch was mocked to fail. The UI remained stable (no crash), but user-facing error messaging and retry options were not observed.\n\nRecommended next steps to complete verification and remediation:\n1) Reproduce the guest-add submission while monitoring the network/console in developer tools to confirm the patched fetch is actually returning an error response and to capture any console errors.\n2) Submit the expense creation form (Presupuesto -> Añadir -> fill fields -> save) with the same fetch patch to observe whether an error UI appears. Report results.\n3) Attempt a task update flow and submit while fetch is patched to fail to observe error UI.\n4) If no toasts/alerts appear in all flows, inspect the TanStack Query error boundaries and mutation handlers to ensure errors are being caught and surfaced. Ensure error components render messages with role=alert or use aria-live so they are discoverable by automated scans.\n5) Improve UX if needed: keep the modal open on server error, display a clear error message (text and role=alert), and show a retry button. Add logging of the server error message in console for debugging.\n\nCurrent status: testing incomplete. Success=false. Remaining automated tests to run: expense creation submission (1), task update submission (1).",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f428f438-e0d1-7076-0ba4-74b878d0676e/1769633775025949//tmp/test_task/result.webm",
    "created": "2026-01-28T20:51:50.424Z",
    "modified": "2026-01-28T20:56:15.180Z"
  },
  {
    "projectId": "ad26eacd-487e-48e9-874e-686e3d64dc38",
    "testId": "28c4dcab-ae42-451f-bf96-a2722ffb7caa",
    "userId": "f428f438-e0d1-7076-0ba4-74b878d0676e",
    "title": "TC015-SPA Navigation: Tab Switching between Guests, Budget, and Logistics",
    "description": "Test that navigation between tabs in the SPA is seamless without page reloads and state is preserved appropriately.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Presupuesto' (Budget) tab (index 158) to navigate to Budget and then verify the URL updates without a full page reload.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[1]/nav/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Logística' (Logistics) tab (index 6) and then evaluate window.location.href, navigation entry type, document.readyState, and history.state to confirm SPA routing for this navigation.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[1]/nav/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Invitados' (Guests) tab (index 149) and then evaluate window.location.href, navigation entry type, document.readyState, and history.state to confirm SPA routing for this navigation.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[1]/nav/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Start second cycle: click 'Presupuesto' (Budget) tab (index 158) to navigate to Budget, then (after page change) evaluate the URL/navigation state and guest-list persistence.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[1]/nav/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Logística' (index 6) to continue the second cycle, then capture window.location.href, navigation entry type, document.readyState, and history.state to confirm SPA routing and no full page reload.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[1]/nav/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Invitados' (Guests) tab (index 149) to complete the second cycle, then evaluate window.location.href, navigation entry type, document.readyState, history.state, and capture visible guest-related counts/text to verify state persistence.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[1]/nav/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f428f438-e0d1-7076-0ba4-74b878d0676e/1769633938406112//tmp/test_task/result.webm",
    "created": "2026-01-28T20:51:50.457Z",
    "modified": "2026-01-28T20:58:58.521Z"
  },
  {
    "projectId": "ad26eacd-487e-48e9-874e-686e3d64dc38",
    "testId": "9ab3f704-8ede-4253-ae59-0b1b5bd772dc",
    "userId": "f428f438-e0d1-7076-0ba4-74b878d0676e",
    "title": "TC016-Accessibility: Dropdown and Interactive Elements Usability",
    "description": "Ensure all dropdowns, especially status change dropdowns using React Portals, and other interactive UI elements are fully accessible and functional.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Allow the page to finish loading and ensure the Invited (Invitados) tab is active; then attempt to open a guest's status change dropdown (React Portal) so it can be tested.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[1]/nav/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the first guest's status change dropdown (CONFIRMADO) so the React Portal dropdown can be inspected for accessibility and keyboard focus.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[2]/div/table/tbody/tr[1]/td[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the portal menu item 'PENDIENTE' (interactive element index 445) to change the guest status via mouse, wait for DOM update, then inspect menu items, activeElement and visible status button to confirm status change and focus behavior.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Reopen the guest's status dropdown, capture detailed ARIA/role/tabindex/focus attributes for portal items and activeElement, then programmatically focus and dispatch keyboard events on the portal menu items to test keyboard activation and observe whether the status updates. Report results and any failures.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[2]/div/table/tbody/tr/td[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Reopen the guest's status dropdown, capture ARIA/role/tabindex/focus attributes for portal menu items and the activeElement, then programmatically focus the first portal menu item and dispatch Enter (and a click) to test whether keyboard activation updates the guest status; report results and any accessibility issues.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[2]/div/table/tbody/tr/td[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the guest's status dropdown and programmatically focus the first portal menu item, dispatch Enter and click as fallback, then return pre/post visible status and focused element to verify whether keyboard activation updates the status and whether focus management is correct.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[2]/div/table/tbody/tr/td[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the guest's status dropdown, programmatically focus the first portal menu item and dispatch Enter (and click fallback), then return pre/post visible status and focused element to verify whether keyboard activation updates the status and whether focus management is correct.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[2]/div/table/tbody/tr/td[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the first guest's status dropdown (click the visible status button) so the React Portal menu is visible and can be inspected for ARIA attributes and focus behavior. This is the 4th open attempt and will be followed by focused DOM inspection (separately).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div[2]/div/table/tbody/tr/td[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Summary of findings\n- What was tested: The guest status change dropdown implemented via a React Portal (first guest row). Interaction methods tested: pointer (mouse), standard keyboard events (ArrowDown, Enter) and programmatic DOM/ARIA inspection.\n\n- Observed behavior\n  - Mouse: Clicking a portal menu item (e.g., 'PENDIENTE') reliably updated the visible guest status.\n  - Keyboard: Sending ArrowDown and Enter while the dropdown was opened did not change the guest status. The page's activeElement typically remained the original status trigger button, indicating focus did not reliably move into the portal menu.\n  - ARIA/semantics: No menu wrapper with role=\"menu\" or menu-specific ARIA attributes (aria-haspopup, aria-expanded) were detected on the trigger or menu wrapper in successful DOM reads. Portal menu items are BUTTON elements with no explicit role, tabindex attributes were null/absent.\n  - JS reliability: Several programmatic DOM inspections intermittently threw uncaught JS errors, making automated checks unreliable in some runs (JS evaluate failures observed). When JS reads succeeded, they confirmed the missing ARIA roles and focus behavior above.\n\n- Accessibility impact\n  - Screen readers may not detect this as a proper menu because there is no role=\"menu\"/role=\"menuitem\" or aria-expanded/aria-haspopup on the trigger. Keyboard-only users cannot reliably move focus into or activate menu items via keyboard, so the control is not fully operable via keyboard.\n\n- Immediate evidence (observations)\n  - Portal menu items exist as focusable BUTTONs but lack menu semantics.\n  - activeElement remained the trigger button after sending ArrowDown+Enter.\n  - Mouse activation updated status; keyboard activation did not.\n  - Intermittent JS errors during programmatic inspections hindered automated verification.\n\n- Recommended fixes for developers (priority order)\n  1. Add proper ARIA semantics:\n     - On the trigger button: add aria-haspopup=\"menu\" and update aria-expanded=\"true|false\" when the menu opens/closes.\n     - Add a menu container element around the portal items with role=\"menu\" (and aria-labelledby or aria-label) so assistive tech recognizes it as a menu.\n     - Mark each menu option with role=\"menuitem\" (or role=\"menuitemcheckbox\" if items are checkable). Ensure each menu item is focusable.\n  2. Manage focus on open/close:\n     - When opening the portal menu, programmatically set focus to the first menu item (or the selected item). Use a ref and focus() in a useEffect after the portal renders.\n     - When closing, return focus to the trigger button (the original status button).\n  3. Implement keyboard handling consistent with menu patterns:\n     - Support ArrowDown/ArrowUp to move focus between menu items, Home/End to jump, Enter/Space to activate, and Escape to close and return focus to the trigger.\n     - Ensure activation via keyboard triggers the same codepath as pointer click (no logic that requires pointer events only).\n  4. Ensure portal insertion preserves accessibility:\n     - If the portal is rendered outside the document flow, use aria-owns on the trigger or ensure the menu has the necessary attributes so screen readers can find it.\n  5. Fix JS errors seen during automated checks:\n     - Investigate and resolve intermittent uncaught errors thrown by DOM inspection code—these may indicate unstable DOM conditions or exceptions in page scripts that interfere with automated testing.\n\n- Recommended verification/testing steps after fixes\n  1. Manual keyboard test: open dropdown with keyboard (Tab to trigger, Enter/Space to open), then use ArrowDown/ArrowUp to move focus, Enter to activate an item, and verify visible status updates and focus returns to trigger on close.\n  2. Screen reader test: test with NVDA/JAWS (Windows) and VoiceOver (macOS) to ensure the menu is announced as a menu and items announced as menuitems; verify aria-expanded toggling.\n  3. Automated checks: run an accessibility scanner (axe-core, Lighthouse) and confirm no critical menu-related violations.\n  4. Repeat the programmatic DOM inspection to confirm aria attributes, activeElement behaviour, and absence of JS errors.\n\n- Current status vs. requested goal\n  - Functional: Mouse interactions work; keyboard functionality is not fully functional for the portal dropdown and therefore the accessibility requirement is not satisfied.\n\n- Next recommended actions for the team\n  - Implement the ARIA/focus/keyboard fixes above. After developer changes are deployed, re-run the keyboard + DOM accessibility tests and the automated accessibility scans.\n\nConclusion\n- Result: Not fully accessible/functional. Mouse activation works; keyboard activation & ARIA semantics need fixes. Recommend developer changes (ARIA + focus management + keyboard event handling) and a re-test cycle. Once changes are applied, the automated and manual keyboard tests should be re-run to confirm success.\n\nIf further automated checks are desired, specify whether to: (A) re-run the keyboard + DOM tests after changes, or (B) run a broader axe-core scan of the entire page now. The session will stop here as requested.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/f428f438-e0d1-7076-0ba4-74b878d0676e/1769634075084042//tmp/test_task/result.webm",
    "created": "2026-01-28T20:51:50.466Z",
    "modified": "2026-01-28T21:01:15.219Z"
  }
]
